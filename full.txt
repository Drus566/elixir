
mix.exs
defmodule ElixirExample.MixProject do
  use Mix.Project

  def project do
    [
      app: :elixir_example,
      version: "0.1.0",
      elixir: "~> 1.14",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  def application do
    [
      extra_applications: [:logger],
      mod: {ElixirExample.Application, []}
    ]
  end

  defp deps do
    [
      {:httpoison, "~> 2.0"},
      {:jason, "~> 1.4"}
    ]
  end
end


lib/elixir_example/application.ex
defmodule ElixirExample.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      ElixirExample.Cache,
      ElixirExample.TaskSupervisor,
      {DynamicSupervisor, strategy: :one_for_one, name: ElixirExample.DynamicSupervisor}
    ]

    opts = [strategy: :one_for_one, name: ElixirExample.Supervisor]
    Supervisor.start_link(children, opts)
  end
end


lib/elixir_example/calculator.ex
defmodule ElixirExample.Calculator do
  use GenServer

  # Клиентский API
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end

  def add(pid, a, b), do: GenServer.call(pid, {:add, a, b})
  def multiply(pid, a, b), do: GenServer.call(pid, {:multiply, a, b})
  def factorial(pid, n), do: GenServer.call(pid, {:factorial, n})
  def get_stats(pid), do: GenServer.call(pid, :get_stats)

  # Серверный API (callbacks)
  @impl true
  def init(:ok) do
    {:ok, %{operations_count: 0, last_result: nil}}
  end

  @impl true
  def handle_call({:add, a, b}, _from, state) do
    result = a + b
    new_state = update_stats(state, "add", result)
    {:reply, {:ok, result}, new_state}
  end

  @impl true
  def handle_call({:multiply, a, b}, _from, state) do
    result = a * b
    new_state = update_stats(state, "multiply", result)
    {:reply, {:ok, result}, new_state}
  end

  @impl true
  def handle_call({:factorial, n}, _from, state) when n >= 0 do
    result = calculate_factorial(n)
    new_state = update_stats(state, "factorial", result)
    {:reply, {:ok, result}, new_state}
  end

  @impl true
  def handle_call({:factorial, n}, _from, state) do
    {:reply, {:error, "Number must be non-negative"}, state}
  end

  @impl true
  def handle_call(:get_stats, _from, state) do
    {:reply, state, state}
  end

  defp calculate_factorial(0), do: 1
  defp calculate_factorial(n), do: n * calculate_factorial(n - 1)

  defp update_stats(state, _operation, result) do
    %{
      operations_count: state.operations_count + 1,
      last_result: result
    }
  end
end

lib/elixir_example/cache.ex
defmodule ElixirExample.Cache do
  use GenServer

  # Клиентский API
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, %{}, opts ++ [name: __MODULE__])
  end

  def put(key, value), do: GenServer.cast(__MODULE__, {:put, key, value})
  def get(key), do: GenServer.call(__MODULE__, {:get, key})
  def delete(key), do: GenServer.cast(__MODULE__, {:delete, key})
  def clear, do: GenServer.cast(__MODULE__, :clear)
  def size, do: GenServer.call(__MODULE__, :size)

  # Серверный API
  @impl true
  def init(state) do
    {:ok, state}
  end

  @impl true
  def handle_cast({:put, key, value}, state) do
    {:noreply, Map.put(state, key, value)}
  end

  @impl true
  def handle_cast({:delete, key}, state) do
    {:noreply, Map.delete(state, key)}
  end

  @impl true
  def handle_cast(:clear, _state) do
    {:noreply, %{}}
  end

  @impl true
  def handle_call({:get, key}, _from, state) do
    {:reply, Map.get(state, key), state}
  end

  @impl true
  def handle_call(:size, _from, state) do
    {:reply, map_size(state), state}
  end
end


lib/elixir_example/task_supervisor.ex
defmodule ElixirExample.TaskSupervisor do
  use Supervisor

  def start_link(opts) do
    Supervisor.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    children = [
      {Task.Supervisor, name: ElixirExample.AsyncTaskSupervisor}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def process_list_async(items, processor) when is_list(items) and is_function(processor) do
    Task.Supervisor.async_stream_nolink(
      ElixirExample.AsyncTaskSupervisor,
      items,
      processor,
      max_concurrency: System.schedulers_online() * 2
    )
    |> Stream.map(fn
      {:ok, result} -> {:ok, result}
      {:exit, reason} -> {:error, reason}
    end)
    |> Enum.to_list()
  end
end


lib/elixir_example/web_client.ex
defmodule ElixirExample.WebClient do
  use GenServer

  @api_base "https://jsonplaceholder.typicode.com"

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, opts)
  end

  def fetch_posts(pid), do: GenServer.call(pid, :fetch_posts)
  def fetch_post(pid, id), do: GenServer.call(pid, {:fetch_post, id})

  @impl true
  def init(opts) do
    {:ok, opts}
  end

  @impl true
  def handle_call(:fetch_posts, _from, state) do
    case HTTPoison.get("#{@api_base}/posts") do
      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->
        posts = Jason.decode!(body)
        {:reply, {:ok, posts}, state}

      {:ok, %HTTPoison.Response{status_code: status}} ->
        {:reply, {:error, "HTTP error: #{status}"}, state}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  @impl true
  def handle_call({:fetch_post, id}, _from, state) do
    case HTTPoison.get("#{@api_base}/posts/#{id}") do
      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->
        post = Jason.decode!(body)
        {:reply, {:ok, post}, state}

      {:ok, %HTTPoison.Response{status_code: 404}} ->
        {:reply, {:error, "Post not found"}, state}

      {:ok, %HTTPoison.Response{status_code: status}} ->
        {:reply, {:error, "HTTP error: #{status}"}, state}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end
end

lib/elixir_example.ex
defmodule ElixirExample do
  @moduledoc """
  Основной модуль приложения с примерами использования.
  """

  alias ElixirExample.{Calculator, Cache, WebClient, TaskSupervisor}

  def demo do
    IO.puts("=== Демонстрация Elixir проекта ===\n")

    # Демонстрация калькулятора
    {:ok, calc_pid} = Calculator.start_link()
    demo_calculator(calc_pid)

    # Демонстрация кэша
    demo_cache()

    # Демонстрация асинхронной обработки
    demo_async_processing()

    # Демонстрация работы с веб-API
    demo_web_client()

    IO.puts("\n=== Демонстрация завершена ===")
  end

  defp demo_calculator(pid) do
    IO.puts("1. Демонстрация калькулятора:")

    {:ok, result} = Calculator.add(pid, 5, 3)
    IO.puts("   5 + 3 = #{result}")

    {:ok, result} = Calculator.multiply(pid, 4, 7)
    IO.puts("   4 * 7 = #{result}")

    {:ok, result} = Calculator.factorial(pid, 5)
    IO.puts("   factorial(5) = #{result}")

    stats = Calculator.get_stats(pid)
    IO.puts("   Статистика: #{inspect(stats)}")
    IO.puts()
  end

  defp demo_cache do
    IO.puts("2. Демонстрация кэша:")

    Cache.put(:user_1, %{name: "John", age: 30})
    Cache.put(:user_2, %{name: "Jane", age: 25})
    Cache.put(:config, %{theme: "dark", language: "ru"})

    user1 = Cache.get(:user_1)
    IO.puts("   User 1: #{inspect(user1)}")

    cache_size = Cache.size()
    IO.puts("   Размер кэша: #{cache_size}")

    Cache.delete(:user_2)
    new_size = Cache.size()
    IO.puts("   Размер после удаления: #{new_size}")
    IO.puts()
  end

  defp demo_async_processing do
    IO.puts("3. Демонстрация асинхронной обработки:")

    numbers = 1..10
    processor = fn n -> 
      Process.sleep(100) # Имитация тяжелой операции
      n * n 
    end

    results = TaskSupervisor.process_list_async(numbers, processor)
    squared_numbers = for {:ok, result} <- results, do: result

    IO.puts("   Квадраты чисел 1..10: #{inspect(squared_numbers)}")
    IO.puts()
  end

  defp demo_web_client do
    IO.puts("4. Демонстрация веб-клиента:")

    {:ok, web_pid} = WebClient.start_link()

    case WebClient.fetch_post(web_pid, 1) do
      {:ok, post} ->
        IO.puts("   Получен пост:")
        IO.puts("   Заголовок: #{post["title"]}")
        IO.puts("   Автор: User ##{post["userId"]}")

      {:error, reason} ->
        IO.puts("   Ошибка: #{reason}")
    end
  end
end


config/config.exs
import Config

config :elixir_example,
  cache_ttl: 3600

config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id]




Запуск проекта
Создайте новый проект:

bash
mix new elixir_example
Замените содержимое файлов как показано выше

Установите зависимости:

bash
cd elixir_example
mix deps.get
Запустите демонстрацию:

bash
iex -S mix
В IEx выполните:

elixir
ElixirExample.demo()
